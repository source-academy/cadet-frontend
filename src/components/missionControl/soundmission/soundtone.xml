<?xml version="1.0"?>
<CONTENT xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

<!-- ***********************************************************************
**** Quest #5B
************************************************************************ -->
<TASK 
    kind="quest" 
    coverimage="https://i.imgur.com/FppKoCr.jpg"
    number="Q5B" 
    startdate="2018-09-17T00:00+08" 
    duedate="2018-09-28T23:59+08" 
    title="The Magical Tone Matrix"
>
<READING>Textbook Section 2.5</READING>
<TEXT>
## Background Information

### The Pentatonic Scale
A pentatonic scale, in music, is a musical scale or mode with *five* notes per octave, in contrast to a heptatonic scale (introduced in Mission 14) which has seven notes. Pentatonic scales are extremely prevalent all over the world: they occur in Celtic folk music, German folk music, American music, and musics of many other cultures. They are at the heart of Chinese music (in which the Chinese people call them *gong shang jue zhi yu*), and they are also exactly the musical scale used by the Trebbls for their magical Tone Matrix. Music that uses only pentatonic scales tends to sound pleasant with any combination of the pitches in the scale.

In the magical Tone Matrix of the Trebbls, the five notes used in an octave are C, D, E, G, A. With twelve-tone equal temperament, the pentatonic scale consists of the note numbers 0, 2, 4, 7 and 9, if you number the twelve semitones from 0 to 11.

### The Tone Matrix
A Tone Matrix consists of a 16 by 16 grid, in which the rows represent sounds of different pitches produced by a particular musical instrument. Each column represents a time at which the sound should be played. The player can keep any of the fields full or empty. The matrix starts playing the left-most column, and the sounds corresponding to the full fields of the respective instruments in that column are played concurrently. After a given `distance` seconds, the matrix plays the second column, after another `distance` seconds, it plays the third column, and so on. When it reaches the last column, its starts again at the beginning.

To get a feeling for the tone matrix, go to [http://tonematrix.audiotool.com](http://tonematrix.audiotool.com) and click around --- you will find magic.



This mission has **two** tasks.
</TEXT>
<PROBLEMS>
    <PROBLEM maxgrade="2" maxxp="400" type="programming">
        <TEXT>
To build the Tone Matrix, the first step is to experiment with the harmonic core of the Tone Matrix---the pentatonic scale.

Write a function `pentatonic_scale` that takes two arguments, a base MIDI note `b` and the number `n` of notes to be generated, and returns a list of `n` consecutive ascending notes of the pentatonic scale, starting with `b`.

Thus, the function will have the following type:
```
pentatonic_scale : (number, number) -> list(number)
```

For example, `pentatonic_scale(60, 10)` returns

```
list(60, 62, 64, 67, 69, 72, 74, 76, 79, 81)
```

You can also test using
```
play(consecutively(map(note => trombone(note, 0.5), pentatonic_scale(60, 10))));
```
        </TEXT>
        <SNIPPET>
            <TEMPLATE>
function pentatonic_scale(note, number_of_notes) {
/* your answer here */
}

// test
/* const sample = pentatonic_scale(60, 10);
play(consecutively(map(note => trombone(note, 0.5), sample))); 
*/
            </TEMPLATE>
            <SOLUTION>
// [Marking Scheme]
// 1 mark for attempt
// 1 mark for correct solution
function pentatonic_scale(note, number_of_notes) {
    if (number_of_notes &lt;= 5) {
        const list_of_notes = list(0, 2, 4, 7, 9);
        return build_list(number_of_notes, n => note + list_ref(list_of_notes, n));
    } else {
        return append(pentatonic_scale(note, 5),
                      pentatonic_scale(note + 12, number_of_notes - 5));
    }
}

Alternative solution:
function pentatonic_scale(note, number_of_notes) {
    const pent_scale = list(0, 2, 4, 7, 9);
    return build_list(number_of_notes, 
            x => 
            (note + 12 * math_floor(x / 5)) + list_ref(pent_scale, x % 5));
}

/* const sample = pentatonic_scale(60, 10);
   play(consecutively(map(note => trombone(note, 0.5), sample))); 
*/
                </SOLUTION>
                <GRADER>
                    function test_runner(tc, ans) {
                        if (is_empty_list(tc)) {
                            return true;
                        } else {
                            return (equal(pentatonic_scale(head(head(tc)), tail(head(tc))), head(ans))
                                        &amp;&amp; test_runner(tail(tc), tail(ans)));
                        }
                    }

                    function test_pentatonic_scale() {
                        const test_cases = list(pair(0, 0), pair(0, 10), pair(60, 10), pair(100, 10), pair(1000, 100));
                        const expected_answer = list(

                            [],

                            list(0, 2, 4, 7, 9, 12, 14, 16, 19, 21),

                            list(60, 62, 64, 67, 69, 72, 74, 76, 79, 81),

                            list(100, 102, 104, 107, 109, 112, 114, 116, 119, 121),

                            list(1000, 1002, 1004, 1007, 1009, 1012, 1014, 1016, 1019, 1021, 1024, 1026, 1028, 1031, 1033, 1036, 1038, 1040, 1043, 1045, 1048, 1050, 1052, 1055, 1057, 1060, 1062, 1064, 1067, 1069, 1072, 1074, 1076, 1079, 1081, 1084, 1086, 1088, 1091, 1093, 1096, 1098, 1100, 1103, 1105, 1108, 1110, 1112, 1115, 1117, 1120, 1122, 1124, 1127, 1129, 1132, 1134, 1136, 1139, 1141, 1144, 1146, 1148, 1151, 1153, 1156, 1158, 1160, 1163, 1165, 1168, 1170, 1172, 1175, 1177, 1180, 1182, 1184, 1187, 1189, 1192, 1194, 1196, 1199, 1201, 1204, 1206, 1208, 1211, 1213, 1216, 1218, 1220, 1223, 1225, 1228, 1230, 1232, 1235, 1237)
                        );

                        //0 marks if no attempt 
                        if (pentatonic_scale === undefined) {
                            return 0;
                        } else{
                            return test_runner(test_cases, expected_answer) ? 2 : 1;
                        }
                    }


                    test_pentatonic_scale();                                        
                </GRADER>
            </SNIPPET>
        </PROBLEM>


        <PROBLEM maxgrade="5" maxxp="1000" type="programming">
            <TEXT>
The Source Academy provides a tone matrix that can be accessed any time using the function `get_matrix()`. It returns a list of lists of boolean values, such that

```
list_ref(list_ref(get_matrix(), my_row), my_column);
```

evaluates to `true` if the matrix currently is filled in row `my_row` and column `my_column`, and `false` otherwise. You count the rows starting from the bottom of the matrix, and you count the columns from the left.  Write a function `play_matrix(distance, list_of_sounds)` which continuously plays the tone matrix. The sounds in subsequent columns start playing `distance` seconds from each other. The rows use the sounds given in `list_of_sounds`, such that the first sound is assigned to the bottom-most row, the second sound is assigned to the second row counting from the bottom, so on and so forth. You can assume that there are at least 16 sounds in `list_of_sounds`.

You may find the following HTML5 function handy, which is available in your environment.

`set_timeout(f, t)`: Calls the function f with no arguments after waiting for t milliseconds.

Try calling the function in the console as follows

```
function f() { display("Sorry I'm late!"); }
set_timeout(f, 1000);
```
and observe what happens.

To aptly conclude the sound missions, provide a function `stop_matrix`, which when called with no arguments, should stop the matrix. It's ok to play on for a few seconds.

For this last task, you may find the following given function useful.

`clear_all_timeout()`: Cancels all previously scheduled but not started set_timeout jobs.

You may find the following behaviors of `set_timeout` useful:

- The second argument does not always imply the actual delay, e.g

```
function f() { display('Test'); }
set_timeout(f, 100);
someComputationThatTake3s();
// Only 3 seconds later Test is displayed
```

- The function passed is evaluated asynchronously , i.e

```
set_timeout(f, 0);
display('Hey');
// 'Test' will be displayed AFTER 'Hey'
```
            </TEXT>
            <SNIPPET>
                <TEMPLATE>
function play_matrix(distance, list_of_sounds) {
    /* your answer here */
}

function stop_matrix() {
    /* your answer here */
}

/* const scales = pentatonic_scale(60, 16);
   const sounds = map(n => piano(n, 1), scales);
   play_matrix(0.5, sounds); */
                </TEMPLATE>
                <SOLUTION>
// [Marking Scheme]
// 1 mark for attempt
// 1 mark for correct solution
// 1 mark for playing silence or no sound if a cell is empty
// 1 mark for repeatedly playing the matrix
// 1 mark for stop_matrix

function pentatonic_scale(note, number_of_notes) {
    const pent_scale = list(0, 2, 4, 7, 9);
    return build_list(number_of_notes, 
            x => 
            (note + 12 * math_floor(x / 5)) + list_ref(pent_scale, x % 5));
}

function mute(note, duration) {
    return silence_sound(duration);
}

function play_matrix(distance, list_of_sounds) {
    // auxiliary function to be called repeatedly
    function play_matrix_sounds(counter_of_column) {
        const matrix = get_matrix();

        function get_column(n) {
            return build_list(length(matrix), x => list_ref(list_ref(matrix, x), n));
        }

        function get_column_sounds(column, list_of_sounds, result) {
            if (is_null(column)) {
                return is_null(result) ? list(mute(0, distance)) : result;
            } else if (head(column)) {
                return get_column_sounds(tail(column), tail(list_of_sounds), pair(head(list_of_sounds), result));
            } else {
                return get_column_sounds(tail(column), tail(list_of_sounds), result);
            }
        }

        const column = get_column(counter_of_column % 16);
        const sound = simultaneously(get_column_sounds(column, list_of_sounds, null));
        play(sound);

        function advance_matrix() {
            play_matrix_sounds(counter_of_column + 1);
        }
        set_timeout(advance_matrix, distance * 1000);
    }

    play_matrix_sounds(0);
}

function stop_matrix() {
    clear_all_timeout();
}

/* const scales = pentatonic_scale(60, 16);
   const sounds = map(n => piano(n, 1), scales);
   play_matrix(0.5, sounds); */
                </SOLUTION>
            </SNIPPET>
        </PROBLEM>
    </PROBLEMS>
    <TEXT>
## Submission

Make sure that everything for your programs to work is on the left hand side and **not** in the interpreter pane on the right!

IMPORTANT: Make sure you've saved the latest version of your work by clicking the "Save" button before finalizing your submission!
    </TEXT>

    <GRADERDEPLOYMENT interpreter="2">
      <EXTERNAL name="SOUND">
            <SYMBOL>make_sourcesound</SYMBOL>
            <SYMBOL>get_wave</SYMBOL>
            <SYMBOL>get_duration</SYMBOL>
            <SYMBOL>play</SYMBOL>
            <SYMBOL>sound_to_sourcesound</SYMBOL>
            <SYMBOL>sourcesound_to_sound</SYMBOL>

            <SYMBOL>silence_sound</SYMBOL>
            <SYMBOL>play</SYMBOL>
            <SYMBOL>adsr</SYMBOL>
            <SYMBOL>stacking_adsr</SYMBOL>
            <SYMBOL>sine_sound</SYMBOL>
            <SYMBOL>sawtooth_sound</SYMBOL>
            <SYMBOL>triangle_sound</SYMBOL>
            <SYMBOL>square_sound</SYMBOL>
            <SYMBOL>midi_note_to_frequency</SYMBOL>
            <SYMBOL>letter_name_to_midi_note</SYMBOL>
            <SYMBOL>get_matrix</SYMBOL>
            <SYMBOL>clear_matrix</SYMBOL>

            <SYMBOL>trombone</SYMBOL>
            <SYMBOL>piano</SYMBOL>
            <SYMBOL>bell</SYMBOL>
            <SYMBOL>violin</SYMBOL>
            <SYMBOL>cello</SYMBOL>
            <SYMBOL>simultaneously</SYMBOL>
            <SYMBOL>consecutively</SYMBOL>
            <SYMBOL>set_timeout</SYMBOL>
            <SYMBOL>clear_all_timeout</SYMBOL>
      </EXTERNAL>
    </GRADERDEPLOYMENT>
    <DEPLOYMENT interpreter="2">
        <EXTERNAL name="SOUND">
            <SYMBOL>make_sourcesound</SYMBOL>
            <SYMBOL>get_wave</SYMBOL>
            <SYMBOL>get_duration</SYMBOL>
            <SYMBOL>play</SYMBOL>
            <SYMBOL>sound_to_sourcesound</SYMBOL>
            <SYMBOL>sourcesound_to_sound</SYMBOL>

            <SYMBOL>silence_sound</SYMBOL>
            <SYMBOL>play</SYMBOL>
            <SYMBOL>adsr</SYMBOL>
            <SYMBOL>stacking_adsr</SYMBOL>
            <SYMBOL>sine_sound</SYMBOL>
            <SYMBOL>sawtooth_sound</SYMBOL>
            <SYMBOL>triangle_sound</SYMBOL>
            <SYMBOL>square_sound</SYMBOL>
            <SYMBOL>midi_note_to_frequency</SYMBOL>
            <SYMBOL>letter_name_to_midi_note</SYMBOL>
            <SYMBOL>get_matrix</SYMBOL>
            <SYMBOL>clear_matrix</SYMBOL>

            <SYMBOL>trombone</SYMBOL>
            <SYMBOL>piano</SYMBOL>
            <SYMBOL>bell</SYMBOL>
            <SYMBOL>violin</SYMBOL>
            <SYMBOL>cello</SYMBOL>
            <SYMBOL>simultaneously</SYMBOL>
            <SYMBOL>consecutively</SYMBOL>
            <SYMBOL>set_timeout</SYMBOL>
            <SYMBOL>clear_all_timeout</SYMBOL>
        </EXTERNAL> 
    </DEPLOYMENT>
</TASK>

</CONTENT>

